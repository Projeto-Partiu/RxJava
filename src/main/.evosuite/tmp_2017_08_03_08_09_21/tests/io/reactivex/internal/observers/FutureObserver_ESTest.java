/*
 * This file was automatically generated by EvoSuite
 * Thu Aug 03 12:43:53 GMT 2017
 */

package io.reactivex.internal.observers;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import io.reactivex.BackpressureOverflowStrategy;
import io.reactivex.BackpressureStrategy;
import io.reactivex.disposables.CompositeDisposable;
import io.reactivex.disposables.SerialDisposable;
import io.reactivex.functions.BooleanSupplier;
import io.reactivex.internal.disposables.DisposableHelper;
import io.reactivex.internal.disposables.EmptyDisposable;
import io.reactivex.internal.observers.FutureObserver;
import io.reactivex.internal.subscriptions.EmptySubscription;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.ArrayListSupplier;
import io.reactivex.internal.util.ErrorMode;
import io.reactivex.internal.util.HashMapSupplier;
import io.reactivex.internal.util.ListAddBiConsumer;
import io.reactivex.plugins.RxJavaPlugins;
import java.io.UnsupportedEncodingException;
import java.sql.BatchUpdateException;
import java.sql.SQLClientInfoException;
import java.sql.SQLDataException;
import java.sql.SQLException;
import java.sql.SQLIntegrityConstraintViolationException;
import java.sql.SQLNonTransientException;
import java.sql.SQLRecoverableException;
import java.sql.SQLSyntaxErrorException;
import java.sql.SQLTransientConnectionException;
import java.sql.SQLWarning;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.Consumer;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.evosuite.runtime.mock.java.lang.MockThrowable;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class FutureObserver_ESTest extends FutureObserver_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      FutureObserver<ErrorMode> futureObserver0 = new FutureObserver<ErrorMode>();
      ErrorMode errorMode0 = ErrorMode.IMMEDIATE;
      futureObserver0.countDown();
      futureObserver0.getCount();
      futureObserver0.value = errorMode0;
      futureObserver0.await();
      futureObserver0.get();
      futureObserver0.onError((Throwable) null);
      futureObserver0.isDone();
      FutureObserver<EmptyDisposable> futureObserver1 = new FutureObserver<EmptyDisposable>();
      TimeUnit timeUnit0 = TimeUnit.SECONDS;
      futureObserver1.await(0L, timeUnit0);
      futureObserver1.error = null;
      futureObserver1.isDone();
      FutureObserver<Object> futureObserver2 = new FutureObserver<Object>();
      TimeUnit timeUnit1 = TimeUnit.MILLISECONDS;
      try { 
        futureObserver2.get(15L, timeUnit1);
        fail("Expecting exception: TimeoutException");
      
      } catch(TimeoutException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      FutureObserver<Object> futureObserver0 = new FutureObserver<Object>();
      SQLException sQLException0 = new SQLException();
      SQLWarning sQLWarning0 = new SQLWarning("", "More than one element received", sQLException0);
      SQLSyntaxErrorException sQLSyntaxErrorException0 = new SQLSyntaxErrorException("More than one element received", sQLWarning0);
      sQLWarning0.setNextException(sQLException0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      sQLException0.forEach(consumer0);
      sQLException0.getStackTrace();
      sQLWarning0.getSuppressed();
      sQLException0.getLocalizedMessage();
      sQLSyntaxErrorException0.printStackTrace();
      futureObserver0.onError((Throwable) null);
      MockThrowable mockThrowable0 = new MockThrowable(sQLSyntaxErrorException0);
      futureObserver0.onError(mockThrowable0);
      FutureObserver<EmptySubscription> futureObserver1 = new FutureObserver<EmptySubscription>();
      TimeUnit timeUnit0 = TimeUnit.NANOSECONDS;
      try { 
        futureObserver1.get((-2824L), timeUnit0);
        fail("Expecting exception: TimeoutException");
      
      } catch(TimeoutException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      FutureObserver<HashMapSupplier> futureObserver0 = new FutureObserver<HashMapSupplier>();
      futureObserver0.onComplete();
      futureObserver0.onError((Throwable) null);
      futureObserver0.cancel(true);
      FutureObserver<BackpressureStrategy> futureObserver1 = new FutureObserver<BackpressureStrategy>();
      futureObserver1.error = null;
      futureObserver1.onError((Throwable) null);
      futureObserver1.isDisposed();
      FutureObserver<EmptyDisposable> futureObserver2 = new FutureObserver<EmptyDisposable>();
      futureObserver2.onError((Throwable) null);
      TimeUnit timeUnit0 = TimeUnit.SECONDS;
      futureObserver2.get((-1371L), timeUnit0);
      FutureObserver<Object> futureObserver3 = new FutureObserver<Object>();
      futureObserver3.isCancelled();
      RxJavaPlugins.setFailOnNonBlockingScheduler(true);
      futureObserver3.isCancelled();
      FutureObserver<ListAddBiConsumer> futureObserver4 = new FutureObserver<ListAddBiConsumer>();
      futureObserver4.isCancelled();
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      FutureObserver<DisposableHelper> futureObserver0 = new FutureObserver<DisposableHelper>();
      futureObserver0.countDown();
      futureObserver0.get();
      FutureObserver<Object> futureObserver1 = new FutureObserver<Object>();
      futureObserver1.isDone();
      FutureObserver<BackpressureStrategy> futureObserver2 = new FutureObserver<BackpressureStrategy>();
      SQLIntegrityConstraintViolationException sQLIntegrityConstraintViolationException0 = new SQLIntegrityConstraintViolationException((String) null);
      futureObserver2.onError(sQLIntegrityConstraintViolationException0);
      futureObserver2.isCancelled();
      FutureObserver<HashMapSupplier> futureObserver3 = new FutureObserver<HashMapSupplier>();
      futureObserver3.isDisposed();
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      FutureObserver<ArrayListSupplier> futureObserver0 = new FutureObserver<ArrayListSupplier>();
      futureObserver0.toString();
      SQLRecoverableException sQLRecoverableException0 = new SQLRecoverableException("ekTAMM])", "", 2796);
      futureObserver0.onError(sQLRecoverableException0);
      SQLRecoverableException sQLRecoverableException1 = new SQLRecoverableException("Zero publishers not supported", "More than one element received");
      futureObserver0.onError(sQLRecoverableException1);
      FutureObserver<BackpressureStrategy> futureObserver1 = new FutureObserver<BackpressureStrategy>();
      futureObserver1.onComplete();
      TimeUnit timeUnit0 = TimeUnit.NANOSECONDS;
      try { 
        futureObserver1.get(0L, timeUnit0);
        fail("Expecting exception: ExecutionException");
      
      } catch(ExecutionException e) {
         //
         // java.util.NoSuchElementException: The source is empty
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      FutureObserver<HashMapSupplier> futureObserver0 = new FutureObserver<HashMapSupplier>();
      futureObserver0.onComplete();
      futureObserver0.onComplete();
      FutureObserver<SubscriptionHelper> futureObserver1 = new FutureObserver<SubscriptionHelper>();
      futureObserver1.getCount();
      TimeUnit timeUnit0 = TimeUnit.HOURS;
      try { 
        futureObserver1.get((-1437L), timeUnit0);
        fail("Expecting exception: TimeoutException");
      
      } catch(TimeoutException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      FutureObserver<BackpressureOverflowStrategy> futureObserver0 = new FutureObserver<BackpressureOverflowStrategy>();
      BackpressureOverflowStrategy backpressureOverflowStrategy0 = BackpressureOverflowStrategy.DROP_LATEST;
      futureObserver0.onNext(backpressureOverflowStrategy0);
      futureObserver0.isCancelled();
      BooleanSupplier booleanSupplier0 = mock(BooleanSupplier.class, new ViolatedAssumptionAnswer());
      RxJavaPlugins.setOnBeforeBlocking(booleanSupplier0);
      futureObserver0.onComplete();
      futureObserver0.isCancelled();
      FutureObserver<EmptySubscription> futureObserver1 = new FutureObserver<EmptySubscription>();
      TimeUnit timeUnit0 = TimeUnit.MINUTES;
      try { 
        futureObserver1.get(0L, timeUnit0);
        fail("Expecting exception: TimeoutException");
      
      } catch(TimeoutException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      FutureObserver<BackpressureStrategy> futureObserver0 = new FutureObserver<BackpressureStrategy>();
      futureObserver0.cancel(false);
      futureObserver0.cancel(true);
      FutureObserver<BackpressureOverflowStrategy> futureObserver1 = new FutureObserver<BackpressureOverflowStrategy>();
      RxJavaPlugins.setFailOnNonBlockingScheduler(true);
      futureObserver1.toString();
      futureObserver1.cancel(false);
      FutureObserver<String> futureObserver2 = new FutureObserver<String>();
      futureObserver2.onSubscribe(futureObserver0);
      FutureObserver<Object> futureObserver3 = new FutureObserver<Object>();
      futureObserver3.onNext("io.reactivex.internal.observers.FutureObserver@69205750[Count = 1]");
      futureObserver1.isDisposed();
      futureObserver2.isCancelled();
      FutureObserver<EmptySubscription> futureObserver4 = new FutureObserver<EmptySubscription>();
      futureObserver4.isDisposed();
      FutureObserver<DisposableHelper> futureObserver5 = new FutureObserver<DisposableHelper>();
      SQLDataException sQLDataException0 = new SQLDataException("vee]I0LG=\"D`/");
      futureObserver5.onError(sQLDataException0);
      Object object0 = new Object();
      // Undeclared exception!
      try { 
        futureObserver3.onNext(object0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      FutureObserver<HashMapSupplier> futureObserver0 = new FutureObserver<HashMapSupplier>();
      SQLIntegrityConstraintViolationException sQLIntegrityConstraintViolationException0 = new SQLIntegrityConstraintViolationException("");
      sQLIntegrityConstraintViolationException0.fillInStackTrace();
      futureObserver0.onError(sQLIntegrityConstraintViolationException0);
      boolean boolean0 = futureObserver0.cancel(false);
      assertFalse(boolean0);
      
      boolean boolean1 = futureObserver0.cancel(true);
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      FutureObserver<SubscriptionHelper> futureObserver0 = new FutureObserver<SubscriptionHelper>();
      SerialDisposable serialDisposable0 = new SerialDisposable(futureObserver0);
      serialDisposable0.set(futureObserver0);
      boolean boolean0 = futureObserver0.cancel(true);
      assertTrue(boolean0);
      
      futureObserver0.onSubscribe(serialDisposable0);
      SQLIntegrityConstraintViolationException sQLIntegrityConstraintViolationException0 = new SQLIntegrityConstraintViolationException("", "");
      futureObserver0.onError(sQLIntegrityConstraintViolationException0);
      FutureObserver<ErrorMode> futureObserver1 = new FutureObserver<ErrorMode>();
      futureObserver1.isCancelled();
      FutureObserver<BackpressureStrategy> futureObserver2 = new FutureObserver<BackpressureStrategy>();
      boolean boolean1 = futureObserver2.isCancelled();
      assertFalse(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      FutureObserver<EmptyDisposable> futureObserver0 = new FutureObserver<EmptyDisposable>();
      futureObserver0.getCount();
      futureObserver0.cancel(false);
      TimeUnit timeUnit0 = TimeUnit.MINUTES;
      // Undeclared exception!
      try { 
        futureObserver0.get(1310L, timeUnit0);
        fail("Expecting exception: CancellationException");
      
      } catch(CancellationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      FutureObserver<DisposableHelper> futureObserver0 = new FutureObserver<DisposableHelper>();
      futureObserver0.toString();
      futureObserver0.cancel(false);
      FutureObserver<ArrayListSupplier> futureObserver1 = new FutureObserver<ArrayListSupplier>();
      futureObserver1.onComplete();
      futureObserver0.dispose();
      FutureObserver<BackpressureOverflowStrategy> futureObserver2 = new FutureObserver<BackpressureOverflowStrategy>();
      BackpressureOverflowStrategy backpressureOverflowStrategy0 = BackpressureOverflowStrategy.DROP_OLDEST;
      futureObserver2.onNext(backpressureOverflowStrategy0);
      DisposableHelper disposableHelper0 = DisposableHelper.DISPOSED;
      futureObserver0.value = disposableHelper0;
      FutureObserver<Object> futureObserver3 = new FutureObserver<Object>();
      futureObserver3.isDone();
      FutureObserver<EmptySubscription> futureObserver4 = new FutureObserver<EmptySubscription>();
      EmptySubscription emptySubscription0 = EmptySubscription.INSTANCE;
      futureObserver4.onNext(emptySubscription0);
      FutureObserver<SerialDisposable> futureObserver5 = new FutureObserver<SerialDisposable>();
      futureObserver5.isDisposed();
      FutureObserver<EmptyDisposable> futureObserver6 = new FutureObserver<EmptyDisposable>();
      futureObserver6.dispose();
      FutureObserver<String> futureObserver7 = new FutureObserver<String>();
      futureObserver7.onSubscribe(futureObserver1);
      futureObserver2.value = backpressureOverflowStrategy0;
      futureObserver3.onSubscribe(futureObserver5);
      // Undeclared exception!
      try { 
        futureObserver0.get();
        fail("Expecting exception: CancellationException");
      
      } catch(CancellationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      FutureObserver<DisposableHelper> futureObserver0 = new FutureObserver<DisposableHelper>();
      futureObserver0.countDown();
      futureObserver0.onComplete();
      try { 
        futureObserver0.get();
        fail("Expecting exception: ExecutionException");
      
      } catch(ExecutionException e) {
         //
         // java.util.NoSuchElementException: The source is empty
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      FutureObserver<Object> futureObserver0 = new FutureObserver<Object>();
      FutureObserver<Integer> futureObserver1 = new FutureObserver<Integer>();
      futureObserver1.error = null;
      futureObserver1.cancel(false);
      futureObserver1.isCancelled();
      FutureObserver<ErrorMode> futureObserver2 = new FutureObserver<ErrorMode>();
      futureObserver2.dispose();
      FutureObserver<EmptySubscription> futureObserver3 = new FutureObserver<EmptySubscription>();
      EmptySubscription emptySubscription0 = EmptySubscription.INSTANCE;
      futureObserver3.onNext(emptySubscription0);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      FutureObserver<ArrayListSupplier> futureObserver0 = new FutureObserver<ArrayListSupplier>();
      futureObserver0.onComplete();
      TimeUnit timeUnit0 = TimeUnit.MICROSECONDS;
      try { 
        futureObserver0.get((-1L), timeUnit0);
        fail("Expecting exception: ExecutionException");
      
      } catch(ExecutionException e) {
         //
         // java.util.NoSuchElementException: The source is empty
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      FutureObserver<BackpressureOverflowStrategy> futureObserver0 = new FutureObserver<BackpressureOverflowStrategy>();
      boolean boolean0 = futureObserver0.isDone();
      FutureObserver<CompositeDisposable> futureObserver1 = new FutureObserver<CompositeDisposable>();
      futureObserver1.countDown();
      boolean boolean1 = futureObserver1.isDone();
      assertFalse(boolean1 == boolean0);
      assertTrue(boolean1);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      FutureObserver<Object> futureObserver0 = new FutureObserver<Object>();
      FutureObserver<EmptySubscription> futureObserver1 = new FutureObserver<EmptySubscription>();
      futureObserver0.onSubscribe(futureObserver1);
      futureObserver0.onError((Throwable) null);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      FutureObserver<ArrayListSupplier> futureObserver0 = new FutureObserver<ArrayListSupplier>();
      futureObserver0.onComplete();
      ArrayListSupplier arrayListSupplier0 = ArrayListSupplier.INSTANCE;
      futureObserver0.onNext(arrayListSupplier0);
      futureObserver0.onComplete();
      SQLClientInfoException sQLClientInfoException0 = new SQLClientInfoException();
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream("cR7kd*n^6Yb", "cR7kd*n^6Yb");
        fail("Expecting exception: UnsupportedEncodingException");
      
      } catch(Throwable e) {
         //
         // cR7kd*n^6Yb
         //
         verifyException("java.io.PrintStream", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      FutureObserver<ArrayListSupplier> futureObserver0 = new FutureObserver<ArrayListSupplier>();
      futureObserver0.dispose();
      int[] intArray0 = new int[3];
      intArray0[0] = 0;
      intArray0[1] = 9;
      intArray0[2] = 3021;
      BatchUpdateException batchUpdateException0 = new BatchUpdateException("", intArray0);
      SQLNonTransientException sQLNonTransientException0 = new SQLNonTransientException((String) null, "", batchUpdateException0);
      SQLTransientConnectionException sQLTransientConnectionException0 = new SQLTransientConnectionException("", sQLNonTransientException0);
      futureObserver0.onError(sQLTransientConnectionException0);
      FutureObserver<EmptySubscription> futureObserver1 = new FutureObserver<EmptySubscription>();
      futureObserver1.dispose();
      boolean boolean0 = futureObserver0.isDisposed();
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      FutureObserver<SubscriptionHelper> futureObserver0 = new FutureObserver<SubscriptionHelper>();
      futureObserver0.isDisposed();
      SubscriptionHelper subscriptionHelper0 = SubscriptionHelper.CANCELLED;
      futureObserver0.onNext(subscriptionHelper0);
      FutureObserver<String> futureObserver1 = new FutureObserver<String>();
      futureObserver1.isCancelled();
      futureObserver1.countDown();
      futureObserver1.cancel(false);
      FutureObserver<ErrorMode> futureObserver2 = new FutureObserver<ErrorMode>();
      SQLTransientConnectionException sQLTransientConnectionException0 = new SQLTransientConnectionException("");
      futureObserver2.onError(sQLTransientConnectionException0);
      FutureObserver<Object> futureObserver3 = new FutureObserver<Object>();
      futureObserver3.countDown();
      futureObserver3.toString();
      futureObserver3.isCancelled();
      FutureObserver<EmptySubscription> futureObserver4 = new FutureObserver<EmptySubscription>();
      futureObserver4.isDone();
      FutureObserver<EmptyDisposable> futureObserver5 = new FutureObserver<EmptyDisposable>();
      futureObserver5.isDisposed();
      FutureObserver<DisposableHelper> futureObserver6 = new FutureObserver<DisposableHelper>();
      futureObserver6.cancel(true);
      FutureObserver<BackpressureOverflowStrategy> futureObserver7 = new FutureObserver<BackpressureOverflowStrategy>();
      TimeUnit timeUnit0 = TimeUnit.MICROSECONDS;
      try { 
        futureObserver7.get(399L, timeUnit0);
        fail("Expecting exception: TimeoutException");
      
      } catch(TimeoutException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.reactivex.internal.observers.FutureObserver", e);
      }
  }
}
