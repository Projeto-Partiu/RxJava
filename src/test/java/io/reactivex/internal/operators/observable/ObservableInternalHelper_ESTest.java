/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

/*
 * This file was automatically generated by EvoSuite
 * Thu Aug 03 14:45:08 GMT 2017
 */

package io.reactivex.internal.operators.observable;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import io.reactivex.Emitter;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.functions.BiConsumer;
import io.reactivex.functions.BiFunction;
import io.reactivex.functions.Function;
import io.reactivex.internal.operators.observable.ObservableInternalHelper;
import io.reactivex.internal.operators.observable.ObservableReplay;
import java.sql.BatchUpdateException;
import java.sql.DataTruncation;
import java.sql.SQLClientInfoException;
import java.sql.SQLException;
import java.sql.SQLIntegrityConstraintViolationException;
import java.sql.SQLInvalidAuthorizationSpecException;
import java.sql.SQLNonTransientException;
import java.sql.SQLSyntaxErrorException;
import java.sql.SQLTimeoutException;
import java.sql.SQLTransientConnectionException;
import java.sql.SQLTransientException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class ObservableInternalHelper_ESTest extends ObservableInternalHelper_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test0()  throws Throwable  {
      ObservableInternalHelper.BufferedReplayCallable<SQLTransientConnectionException> observableInternalHelper_BufferedReplayCallable0 = new ObservableInternalHelper.BufferedReplayCallable<SQLTransientConnectionException>((Observable<SQLTransientConnectionException>) null, 0);
      ObservableInternalHelper.ErrorMapperFilter.values();
      ObservableInternalHelper.zipIterable((Function<? super Object[], ? extends SQLTimeoutException>) null);
      Observer<SQLInvalidAuthorizationSpecException> observer0 = (Observer<SQLInvalidAuthorizationSpecException>) mock(Observer.class, new ViolatedAssumptionAnswer());
      ObservableInternalHelper.ObserverOnComplete<SQLInvalidAuthorizationSpecException> observableInternalHelper_ObserverOnComplete0 = new ObservableInternalHelper.ObserverOnComplete<SQLInvalidAuthorizationSpecException>(observer0);
      observableInternalHelper_ObserverOnComplete0.run();
      observableInternalHelper_ObserverOnComplete0.run();
      observableInternalHelper_ObserverOnComplete0.run();
      Observer<SQLInvalidAuthorizationSpecException> observer1 = observableInternalHelper_ObserverOnComplete0.observer;
      ObservableInternalHelper.ObserverOnNext<SQLInvalidAuthorizationSpecException> observableInternalHelper_ObserverOnNext0 = new ObservableInternalHelper.ObserverOnNext<SQLInvalidAuthorizationSpecException>(observer1);
      ObservableInternalHelper.SimpleBiGenerator<DataTruncation, Integer> observableInternalHelper_SimpleBiGenerator0 = new ObservableInternalHelper.SimpleBiGenerator<DataTruncation, Integer>((BiConsumer<Integer, Emitter<DataTruncation>>) null);
      Observer<Emitter<SQLTransientException>> observer2 = (Observer<Emitter<SQLTransientException>>) mock(Observer.class, new ViolatedAssumptionAnswer());
      ObservableInternalHelper.ObserverOnNext<Emitter<SQLTransientException>> observableInternalHelper_ObserverOnNext1 = new ObservableInternalHelper.ObserverOnNext<Emitter<SQLTransientException>>(observer2);
      Emitter<SQLTransientException> emitter0 = (Emitter<SQLTransientException>) mock(Emitter.class, new ViolatedAssumptionAnswer());
      observableInternalHelper_ObserverOnNext1.accept(emitter0);
      ObservableInternalHelper.SimpleGenerator<SQLTransientException, Throwable> observableInternalHelper_SimpleGenerator0 = new ObservableInternalHelper.SimpleGenerator<SQLTransientException, Throwable>(observableInternalHelper_ObserverOnNext1);
      ObservableInternalHelper.ZipIterableFunction<SQLNonTransientException, Throwable> observableInternalHelper_ZipIterableFunction0 = new ObservableInternalHelper.ZipIterableFunction<SQLNonTransientException, Throwable>((Function<? super Object[], ? extends Throwable>) null);
      // Undeclared exception!
      try { 
        ObservableInternalHelper.ErrorMapperFilter.valueOf("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant io.reactivex.internal.operators.observable.ObservableInternalHelper.ErrorMapperFilter.
         //
         verifyException("java.lang.Enum", e);
      }
  }

  @Test(timeout = 4000)
  public void test1()  throws Throwable  {
      Observer<String> observer0 = (Observer<String>) mock(Observer.class, new ViolatedAssumptionAnswer());
      ObservableInternalHelper.ObserverOnNext<String> observableInternalHelper_ObserverOnNext0 = new ObservableInternalHelper.ObserverOnNext<String>(observer0);
      observableInternalHelper_ObserverOnNext0.accept((String) null);
      BiFunction<Object, Object, Integer> biFunction0 = (BiFunction<Object, Object, Integer>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      Integer integer0 = new Integer(7);
      ObservableInternalHelper.FlatMapWithCombinerInner<Integer, Integer, Integer> observableInternalHelper_FlatMapWithCombinerInner0 = new ObservableInternalHelper.FlatMapWithCombinerInner<Integer, Integer, Integer>(biFunction0, integer0);
      BiConsumer<Object, Emitter<SQLIntegrityConstraintViolationException>> biConsumer0 = (BiConsumer<Object, Emitter<SQLIntegrityConstraintViolationException>>) mock(BiConsumer.class, new ViolatedAssumptionAnswer());
      observableInternalHelper_ObserverOnNext0.accept((String) null);
      ObservableInternalHelper.SimpleBiGenerator<SQLIntegrityConstraintViolationException, Object> observableInternalHelper_SimpleBiGenerator0 = new ObservableInternalHelper.SimpleBiGenerator<SQLIntegrityConstraintViolationException, Object>(biConsumer0);
      BiFunction<SQLException, Object, ObservableReplay<SQLClientInfoException>> biFunction1 = (BiFunction<SQLException, Object, ObservableReplay<SQLClientInfoException>>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(biFunction1).apply(any(java.sql.SQLException.class) , any());
      SQLTimeoutException sQLTimeoutException0 = mock(SQLTimeoutException.class, new ViolatedAssumptionAnswer());
      observableInternalHelper_ObserverOnNext0.accept("`!JFQUF,$Dg~");
      ObservableInternalHelper.FlatMapWithCombinerInner<Object, ObservableReplay<SQLClientInfoException>, SQLTimeoutException> observableInternalHelper_FlatMapWithCombinerInner1 = new ObservableInternalHelper.FlatMapWithCombinerInner<Object, ObservableReplay<SQLClientInfoException>, SQLTimeoutException>(biFunction1, sQLTimeoutException0);
      observableInternalHelper_FlatMapWithCombinerInner1.apply(observableInternalHelper_ObserverOnNext0);
      ObservableInternalHelper.RepeatWhenOuterHandler observableInternalHelper_RepeatWhenOuterHandler0 = new ObservableInternalHelper.RepeatWhenOuterHandler(observableInternalHelper_FlatMapWithCombinerInner1);
      SQLSyntaxErrorException sQLSyntaxErrorException0 = mock(SQLSyntaxErrorException.class, new ViolatedAssumptionAnswer());
      ObservableInternalHelper.FlatMapWithCombinerInner<SQLNonTransientException, DataTruncation, SQLSyntaxErrorException> observableInternalHelper_FlatMapWithCombinerInner2 = new ObservableInternalHelper.FlatMapWithCombinerInner<SQLNonTransientException, DataTruncation, SQLSyntaxErrorException>((BiFunction<? super SQLSyntaxErrorException, ? super SQLNonTransientException, ? extends DataTruncation>) null, sQLSyntaxErrorException0);
      ObservableInternalHelper.ObserverOnNext<Emitter<Object>> observableInternalHelper_ObserverOnNext1 = new ObservableInternalHelper.ObserverOnNext<Emitter<Object>>((Observer<Emitter<Object>>) null);
      ObservableInternalHelper.SimpleGenerator<Object, BatchUpdateException> observableInternalHelper_SimpleGenerator0 = new ObservableInternalHelper.SimpleGenerator<Object, BatchUpdateException>(observableInternalHelper_ObserverOnNext1);
      BatchUpdateException batchUpdateException0 = mock(BatchUpdateException.class, new ViolatedAssumptionAnswer());
      Emitter<Object> emitter0 = (Emitter<Object>) mock(Emitter.class, new ViolatedAssumptionAnswer());
      try { 
        observableInternalHelper_SimpleGenerator0.apply(batchUpdateException0, emitter0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.reactivex.internal.operators.observable.ObservableInternalHelper$ObserverOnNext", e);
      }
  }
}
