/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

/*
 * This file was automatically generated by EvoSuite
 * Thu Aug 03 13:14:48 GMT 2017
 */

package io.reactivex.internal.schedulers;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import io.reactivex.BackpressureOverflowStrategy;
import io.reactivex.BackpressureStrategy;
import io.reactivex.disposables.CompositeDisposable;
import io.reactivex.disposables.Disposable;
import io.reactivex.functions.Consumer;
import io.reactivex.internal.schedulers.InstantPeriodicTask;
import io.reactivex.internal.schedulers.RxThreadFactory;
import io.reactivex.internal.schedulers.ScheduledRunnable;
import io.reactivex.internal.subscriptions.EmptySubscription;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.ErrorMode;
import io.reactivex.plugins.RxJavaPlugins;
import java.util.PriorityQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.Supplier;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.lang.MockThread;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class InstantPeriodicTask_ESTest extends InstantPeriodicTask_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test0()  throws Throwable  {
      ThreadGroup threadGroup0 = new ThreadGroup("Hgsl,,");
      MockThread mockThread0 = new MockThread(threadGroup0, "Hgsl,,");
      ForkJoinPool forkJoinPool0 = new ForkJoinPool();
      forkJoinPool0.getAsyncMode();
      forkJoinPool0.toString();
      InstantPeriodicTask instantPeriodicTask0 = new InstantPeriodicTask(mockThread0, forkJoinPool0);
      instantPeriodicTask0.call();
      Supplier<EmptySubscription> supplier0 = (Supplier<EmptySubscription>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      MockThread.setDefaultUncaughtExceptionHandler(threadGroup0);
      CompletableFuture<EmptySubscription> completableFuture0 = CompletableFuture.supplyAsync(supplier0);
      CompletableFuture<EmptySubscription> completableFuture1 = completableFuture0.toCompletableFuture();
      // Undeclared exception!
      instantPeriodicTask0.setRest(completableFuture1);
  }

  @Test(timeout = 4000)
  public void test1()  throws Throwable  {
      MockThread mockThread0 = new MockThread("io.reactivex.internal.schedulers.InstantPeriodicTask");
      MockThread mockThread1 = new MockThread(mockThread0, "io.reactivex.internal.schedulers.InstantPeriodicTask");
      SubscriptionHelper subscriptionHelper0 = SubscriptionHelper.CANCELLED;
      CompletableFuture.completedFuture(subscriptionHelper0);
      ClassLoader classLoader0 = mockThread0.getContextClassLoader();
      ClassLoader classLoader1 = classLoader0.getParent();
      mockThread0.setContextClassLoader(classLoader1);
      ForkJoinPool forkJoinPool0 = ForkJoinPool.commonPool();
      InstantPeriodicTask instantPeriodicTask0 = new InstantPeriodicTask(mockThread0, forkJoinPool0);
      instantPeriodicTask0.dispose();
      InstantPeriodicTask instantPeriodicTask1 = new InstantPeriodicTask(mockThread0, forkJoinPool0);
      instantPeriodicTask1.call();
  }

  @Test(timeout = 4000)
  public void test2()  throws Throwable  {
      ThreadGroup threadGroup0 = new ThreadGroup("io.reactivex.internal.schedulers.InstantPeriodicTask");
      MockThread mockThread0 = new MockThread("ajnkLr;t+'%m,7FX3|");
      ClassLoader classLoader0 = mockThread0.getContextClassLoader();
      ClassLoader classLoader1 = ClassLoader.getSystemClassLoader();
      ClassLoader.getSystemClassLoader();
      classLoader1.setClassAssertionStatus("ajnkLr;t+'%m,7FX3|", false);
      classLoader0.setPackageAssertionStatus("", false);
      ClassLoader.getSystemClassLoader();
      mockThread0.setContextClassLoader(classLoader0);
      MockThread mockThread1 = new MockThread(threadGroup0, mockThread0);
      ForkJoinPool forkJoinPool0 = new ForkJoinPool();
      InstantPeriodicTask instantPeriodicTask0 = new InstantPeriodicTask(mockThread1, forkJoinPool0);
      mockThread0.setContextClassLoader(classLoader1);
      instantPeriodicTask0.isDisposed();
      ForkJoinPool.commonPool();
      MockThread.interrupted();
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      RxJavaPlugins.setErrorHandler(consumer0);
      MockThread.reset();
      instantPeriodicTask0.setFirst((Future<?>) null);
      threadGroup0.checkAccess();
      instantPeriodicTask0.setRest((Future<?>) null);
      instantPeriodicTask0.isDisposed();
      instantPeriodicTask0.dispose();
      // Undeclared exception!
      try { 
        instantPeriodicTask0.setFirst((Future<?>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("io.reactivex.internal.schedulers.InstantPeriodicTask", e);
      }
  }

  @Test(timeout = 4000)
  public void test3()  throws Throwable  {
      ForkJoinPool forkJoinPool0 = new ForkJoinPool();
      InstantPeriodicTask instantPeriodicTask0 = new InstantPeriodicTask((Runnable) null, forkJoinPool0);
      // Undeclared exception!
      try { 
        instantPeriodicTask0.call();
        fail("Expecting exception: StackOverflowError");
      
      } catch(StackOverflowError e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test4()  throws Throwable  {
      MockThread mockThread0 = new MockThread((ThreadGroup) null, (Runnable) null, "");
      mockThread0.setUncaughtExceptionHandler((Thread.UncaughtExceptionHandler) null);
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      InstantPeriodicTask instantPeriodicTask0 = new InstantPeriodicTask(mockThread0, scheduledThreadPoolExecutor0);
      TimeUnit timeUnit0 = TimeUnit.MINUTES;
      scheduledThreadPoolExecutor0.schedule((Runnable) mockThread0, (-1693L), timeUnit0);
      instantPeriodicTask0.isDisposed();
      instantPeriodicTask0.dispose();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor1 = new ScheduledThreadPoolExecutor(2299);
      CompositeDisposable compositeDisposable0 = new CompositeDisposable();
      Disposable[] disposableArray0 = new Disposable[5];
      disposableArray0[0] = (Disposable) instantPeriodicTask0;
      disposableArray0[1] = (Disposable) compositeDisposable0;
      disposableArray0[2] = (Disposable) compositeDisposable0;
      disposableArray0[3] = (Disposable) instantPeriodicTask0;
      disposableArray0[4] = (Disposable) instantPeriodicTask0;
      compositeDisposable0.addAll(disposableArray0);
      ScheduledRunnable scheduledRunnable0 = new ScheduledRunnable((Runnable) null, compositeDisposable0);
      scheduledRunnable0.isDisposed();
      Future<Object> future0 = scheduledThreadPoolExecutor1.submit((Callable<Object>) scheduledRunnable0);
      instantPeriodicTask0.setRest(future0);
      instantPeriodicTask0.isDisposed();
      instantPeriodicTask0.isDisposed();
      instantPeriodicTask0.dispose();
      instantPeriodicTask0.dispose();
      instantPeriodicTask0.isDisposed();
      instantPeriodicTask0.dispose();
      instantPeriodicTask0.call();
  }

  @Test(timeout = 4000)
  public void test5()  throws Throwable  {
      RxThreadFactory rxThreadFactory0 = new RxThreadFactory("DX*_Ns:s.", 1646);
      ThreadPoolExecutor.DiscardOldestPolicy threadPoolExecutor_DiscardOldestPolicy0 = new ThreadPoolExecutor.DiscardOldestPolicy();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(1646, rxThreadFactory0, threadPoolExecutor_DiscardOldestPolicy0);
      InstantPeriodicTask instantPeriodicTask0 = new InstantPeriodicTask((Runnable) null, scheduledThreadPoolExecutor0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      RxJavaPlugins.setErrorHandler(consumer0);
      instantPeriodicTask0.isDisposed();
      ForkJoinPool forkJoinPool0 = new ForkJoinPool(1646);
      Callable<BackpressureOverflowStrategy> callable0 = (Callable<BackpressureOverflowStrategy>) mock(Callable.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(callable0).call();
      ForkJoinTask<BackpressureOverflowStrategy> forkJoinTask0 = ForkJoinTask.adapt((Callable<? extends BackpressureOverflowStrategy>) callable0);
      forkJoinTask0.getException();
      ForkJoinTask<BackpressureOverflowStrategy> forkJoinTask1 = forkJoinPool0.submit(forkJoinTask0);
      TimeUnit timeUnit0 = TimeUnit.MILLISECONDS;
      try { 
        forkJoinTask1.get((-1L), timeUnit0);
        fail("Expecting exception: TimeoutException");
      
      } catch(TimeoutException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.concurrent.ForkJoinTask", e);
      }
  }

  @Test(timeout = 4000)
  public void test6()  throws Throwable  {
      ThreadGroup threadGroup0 = new ThreadGroup("");
      ThreadGroup threadGroup1 = new ThreadGroup(threadGroup0, "]>AUrMVN8xMXjBR%");
      Thread thread0 = MockThread.currentThread();
      MockThread mockThread0 = new MockThread(threadGroup0, thread0, " exceptions occurred. ", 547L);
      MockThread mockThread1 = new MockThread(threadGroup0, mockThread0, "io.reactivex.internal.schedulers.InstantPeriodicTask");
      MockThread mockThread2 = new MockThread(threadGroup1, mockThread1);
      TimeUnit timeUnit0 = TimeUnit.NANOSECONDS;
      SynchronousQueue<Runnable> synchronousQueue0 = new SynchronousQueue<Runnable>();
      RxThreadFactory rxThreadFactory0 = new RxThreadFactory((String) null);
      ThreadPoolExecutor.DiscardOldestPolicy threadPoolExecutor_DiscardOldestPolicy0 = new ThreadPoolExecutor.DiscardOldestPolicy();
      ThreadPoolExecutor threadPoolExecutor0 = new ThreadPoolExecutor(400, 400, 400, timeUnit0, synchronousQueue0, rxThreadFactory0, threadPoolExecutor_DiscardOldestPolicy0);
      InstantPeriodicTask instantPeriodicTask0 = new InstantPeriodicTask(mockThread2, threadPoolExecutor0);
      instantPeriodicTask0.isDisposed();
  }

  @Test(timeout = 4000)
  public void test7()  throws Throwable  {
      ThreadGroup threadGroup0 = new ThreadGroup("subscriber returned by the RxJavaPlugins hook is null");
      MockThread mockThread0 = new MockThread(threadGroup0, (Runnable) null, "lguck&1,SZ?pjtbOs)M", 627L);
      ThreadPoolExecutor.DiscardPolicy threadPoolExecutor_DiscardPolicy0 = new ThreadPoolExecutor.DiscardPolicy();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(8, threadPoolExecutor_DiscardPolicy0);
      InstantPeriodicTask instantPeriodicTask0 = new InstantPeriodicTask(mockThread0, scheduledThreadPoolExecutor0);
      threadGroup0.setDaemon(true);
      instantPeriodicTask0.runner = (Thread) mockThread0;
      instantPeriodicTask0.dispose();
      threadGroup0.list();
      ErrorMode errorMode0 = ErrorMode.BOUNDARY;
      CompletableFuture<ErrorMode> completableFuture0 = CompletableFuture.completedFuture(errorMode0);
      instantPeriodicTask0.setFirst(completableFuture0);
      Thread[] threadArray0 = new Thread[1];
      threadArray0[0] = (Thread) mockThread0;
      MockThread.enumerate(threadArray0);
      instantPeriodicTask0.setFirst(completableFuture0);
      instantPeriodicTask0.setRest(completableFuture0);
      instantPeriodicTask0.dispose();
      instantPeriodicTask0.setFirst(completableFuture0);
      scheduledThreadPoolExecutor0.setExecuteExistingDelayedTasksAfterShutdownPolicy(true);
      mockThread0.getStackTrace();
      instantPeriodicTask0.isDisposed();
      instantPeriodicTask0.setFirst(completableFuture0);
      instantPeriodicTask0.dispose();
      instantPeriodicTask0.call();
      assertTrue(instantPeriodicTask0.isDisposed());
  }

  @Test(timeout = 4000)
  public void test8()  throws Throwable  {
      MockThread.currentThread();
      TimeUnit timeUnit0 = TimeUnit.SECONDS;
      PriorityQueue<FutureTask<BackpressureStrategy>> priorityQueue0 = new PriorityQueue<FutureTask<BackpressureStrategy>>();
      LinkedBlockingDeque<Runnable> linkedBlockingDeque0 = new LinkedBlockingDeque<Runnable>(priorityQueue0);
      RxThreadFactory rxThreadFactory0 = new RxThreadFactory("0,-yhz^_l7>~{wq", 0);
      ThreadPoolExecutor threadPoolExecutor0 = null;
      try {
        threadPoolExecutor0 = new ThreadPoolExecutor(0, 0, (-1393L), timeUnit0, linkedBlockingDeque0, rxThreadFactory0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.concurrent.ThreadPoolExecutor", e);
      }
  }
}
